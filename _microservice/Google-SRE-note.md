

# Google SRE 部分记录

[TOC]





# 20.数据中心内部的负载均衡系统



异常任务的简单应对办法:流速控制

- 也是一种非常简单的负载均衡机制:如果某个后端任务过载了, 请求处理开始变慢, 客户端会自动避开这个后端, 从而将任务分配给其他的后端。



服务状态

- 健康
- 拒绝服务
- 跛脚鸭状态

可靠的识别异常任务的方法: **跛脚鸭状态**

- “跛脚鸭”英文是“lame duck”，最早是指负债累累的投资者，经过多年的演变，现用于形容“即将下台的政治家”。而所谓的“跛鸭效应”便是指这些任期将满的议员或政府官员，所提出的议案或政策获得通过执行的可能性很小。

- 跛脚鸭状态: 后端任务正在监听端口, 并且可以服务请求, 但是已经明确要求客户端停止发送请求。

- 跛脚鸭状态的好处就是让无缝停止任务变得更容易

能够无影响地停止一个活跃的后端任务可以让处理代码推送、设备维护活动, 和机器故障问题导致的任务重启变得对用户透明。

一旦后端程序可以提供服务了, 它就会主动通知所有客户端。



**利用划分子集限制连接池大小**

- 限制客户端连接到后端服务数量，或一个后端接受过多的客户端连接；

- 每个连接都需要双方消耗一定数量的内存和CPU(由于定期健康检査导致)来维护。一两个连接开销可能很小，但是达到一定规模之后，开销就不能忽视了；



TCP 模式 转为 UDP 模式连接 ？



轮次的作用是 ？

- 每轮所有的后端都会按特定的步长逐个分给前端，这样可以保证所有的后台都会均匀分到客户端
- 分轮次进行的作用是保证每轮后端都均匀分配到前端

- 每轮进行洗牌，这样引入了前端与后端匹配的随机性，
- 

# 22.连锁故障

集群部分节点挂掉，压力集中到剩余节点导致这些节点负载过高；

看门狗机制 watchdog

CPU使用得越多,任务被分配到多个CPU核心上的几率越大,从而导致CPU核心本地缓存的失效,进而降低CPU处理的效率。



**GC死亡螺旋**

一个槽糕透顶的场景:由于CPU资源减少,请求处理速度变慢,内存使用率上升, 导致GC触发次数增多,导致CPU资源的进一步减少。我们将此称之为“GC死亡螺旋”。



**连锁故障**：资源相互依赖，导致连锁故障，让问题排查更加困难：

GC -> CPU升高 -》请求处理变慢 -〉内存上升 -〉处理变慢 -》 内生升高 -》 缓存命中率下降 -〉请求穿透到后端 -》后端CPU走高健康检测失败 -》 服务故障



**崩溃循环**：这种场景经常很难恢复,因为一旦某个软件服务器恢复正常,它就会接收到大量请求的轰炸, 几乎立即再次崩溃。所以才有了有些网站崩溃之后重启都是逐步慢慢来的。



容量规划：N + 2 模式运行，冗余 20%的节点，

网络分区事件



**服务器队列管理**

大部分“每个请求一个线程”模型的软件服务器使用一个队列和一个线程池来处理请求接收到的请求将会进入队列, 线程池中的线程会将请求从队列中取出来处理, 当队列排满时, 服务器会拒绝新的请求。

当请求速率超过处理的速率时，就会开始排队，在队列中的排队请求消耗内存, 同时使延退升高。

当服务处理速度无法跟上请求到达速率时, 尽早拒绝请求会更好。

无队列软件服务器。负载转移到其他服务器上。



**请求超时设置非常必要**

连锁故障场景下的一个常见问题是服务器消耗大量资源处理那些已经超过客户端截止时间的请求。

如果处理请求的过程有多个阶段, 服务器应该在每个阶段开始前检査截止时间, 以避免做无用功。例如,如果一个请求被分解为解析请求阶段、发送后端请求阶段和处理阶段, 那么可能在每个阶段开始之前都要检査是否还有足够剩余时间处理请求。

**超时传递取消**： 全局超时控制

与其在发送 RPC 给后端服务器时自拟一个超时时间, 不如让服务器采用超时时间传递和取消策略，



RPC 取消传递

请求延迟的双峰分布(Bimodal)

如果无法完成的请求能够尽早返回一个错误而不是等完整个截止时间

保持调用栈永远向下



连锁故障的测试

- 测试直到出现故障,还要继续测试

- 理解服务在高负载情况下的行为模式可能是避免连锁反应最重要的一步；
- 压力测试每个组件直到它们崩溃；
- 压力测试找出系统临界点，这是容量规划流程的关键所在；

- 每个独立组件都可能有不同的临界点、所以应该分别测试。

解决连锁故障的及时步骤

- 增加资源，如果系统容量不足, 而有足够的空闲资源, 增加任务数量可能是最快的解决方案；如果服务已经进入了某种死亡螺旋,只增加资源可能不能完全解决问题；
- 停止健康检查导致的任务死亡，当设计网络波动，发版等，尤其当检测到不健康节点超过一定阈值时，暂时禁止健康检査可能可以使系统恢复稳定状态；
- 重启大法。尤其在 `GC 死亡螺旋中`，线程池耗尽，死锁等场景。在重启服务之前先确定连锁故障的源头。还要保这种操作不会简单地将流量迁移到別处。最好能够试验性地进行这种改变, 同时`缓慢实施`。如果根本原因是因为冷缓存, 那简单地重启可能使连锁故障更严重,

但是重启的系统，由于其处理能力也是逐渐升上的，如要缓存预热，热点数据加载，流量可能需要逐步放入。



**丟弃流量**

丢弃流量是一个重型操作,通常是在连锁故障严重而无法用其他方式解决时オ会采用。

例如, 如果高负载导致大部分服务器刚一启动就崩溃, 可以通过以下手段将服务恢复到正常水平

1.解决最初的触发原因(如增加容量) 

2.将`负载降低`到一定水平, 使得崩溃停止。考虑在这里激进一些, 如果整个服务都在崩溃循环中、那么可以考虑降低流量到 1% 的水平。

3.允许大部分的软件服务器恢复健康

4.逐渐提升负载水平。

这个策略可以在负载恢复到正常水平之前帮助缓存预热, 逐渐建立连接等。这是建立在故障原因已经找到并解决的基础上。否则恢复到之前到流量很可能再次触发问题。



# 23.管理关键状态:利用分布式共识来提高可靠性

CAP

ACID

BASE

RAFT

PAXOS























